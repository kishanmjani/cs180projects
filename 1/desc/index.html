<!DOCTYPE html>
<html>
<head>
    <title>Proj 1: Methods Used</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            margin: 20px;
        }
    </style>
</head>
<body>
    <h2> Methods Used </h2>
    
    <br>
      Single-Scale Alignment for low-resolution images:

For smaller images (stored in .jpg format: cathedral.jpg, monastery.jpg, tobolsk.jpg), a simple 'single-scale' implementation was used, which involved searching for the optimal displacement (judged by a similarity metric) within a search space. 

 1. Search space used was [-15,15]
 2. Similarity metric: tried L2 norm, L1 norm, and normalized cross-correlation. The one that worked best was the L1 norm. Why? The L2 norm penalizes outlying pixels a lot more than the L1 norm. This ensures that a certain displacement is not misjudged due to outlier behavior towards the borders of the image. 
 3. Tried using a Sobel filter in this situation, produced worse images for some reason. 

Image Pyramid Alignment for high-resolution images:

For larger images (stored in .tif format), a naive single-scale approach is  not efficient for two primary reasons: 

1. The pixel array has larger shape, which makes our exhaustive search take longer. 
2. The optimal displacement is likely larger than what the initial search space [-15,15] explores; for instance, (50,23) for RED and (107,40) for GREEN works well for emir.tif. Thus we would need to expand our search space to something of the order [-100,100] to produce a sharp image with exhaustive search, which blows up the runtime. 

The remedy to these issues comes from using an image pyramid. The idea is to repeatedly scale the image (factor of 2 chosen) until the pixel array is of reasonably small dimensions. Then, we find the optimal displacement (d) for the scaled versions using a smaller search space. For the original image, the corresponding displacement we implement is D = 2**(doubling_factor)*d. This is done using all doubling factors 0,1,2,..., L, with the optimal displacements added from each step. This allows us to explore a wider range of displacements while saving on computational cost. 

Empirically, L=6 was the maximum depth of doubling chosen. 
    <br>
    <br>
    
    
</body>
</html>
